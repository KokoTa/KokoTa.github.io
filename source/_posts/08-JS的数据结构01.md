---
title: 08-JS的数据结构01
date: 2017-12-07 19:12:48
tags:
    - javascript
    - 数构
---
<img src="/images/index/08.jpg" />
<!--more-->

# 数组  
Javascript中提供了数组操作的许多API：  
**concat/every/filter/forEach/join/indexOf/latIndexOf/map/reverse/slice/some/sort/toString/valueOf**  
[它们的具体用法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)  
数组是储存多个元素的容器，JS中对存储的元素类型没有限制，因此你可以在数组中存放诸如String/Boolean/Object等多个类型的数据  

# 栈  
## 实现栈
栈是一个先进后出的数据结构。  
JS中没有栈的概念，但我们可以模拟它：  
```js
function Stack() {
    this.items = [];
}
Stack.prototype = {
    constructor: Stack,
    push (element) {
        this.items.push(element);
    },
    pop () {
        return this.items.pop();
    },
    peak () {
        return this.items[this.items.length - 1];
    },
    isEmpty () {
        return this.items.length === 0;
    },
    clear () {
        this.items = [];
    },
    size () {
        return this.items.length;
    },
    print () {
        console.log(this.items.toString());
    }
}
```
## 栈的应用
```js
// 利用栈实现对正整数的二进制转换
// 一个十进制的数的二进制是这个数余2后的结果集合的反序
function divideBy2(num) {
    let stack = new Stack();
    let rem = 0; // 余数
    let res = '';
    while(num > 0) {
        rem = num % 2;
        stack.push(rem);
        num = Math.floor(num / 2);
    }
    while(!stack.isEmpty()) {
        res += stack.pop().toString();
    }
    return res
}
```

# 队列  
## 实现队列
队列是一个先进先出的数据结构。  
JS中也没有队列的概念，但我们可以模拟它:  
```js
function Queue() {
    this.items = [];
}
Queue.prototype = {
    constructor: Queue,
    enqueue (element) {
        this.items.push(element);
    },
    dequeue (elements) {
        return this.items.shift();
    },
    front () {
        return this.items[0];
    },
    isEmpty () {
        return this.items.length === 0;
    },
    size () {
        return this.items.length;
    },
    clear () {
        this.items = [];
    },
    print () {
        console.log(this.items.toString());
    }
}
```
## 优先队列  
即队列元素的添加和删除的顺序按照元素的权重大小来实现  
这里我们来看看最小优先队列的实现，即按权重从小到大的队列：  
```js
// 继承Queue
function PriorityQueue() {
    Queue.call(this);
}
PriorityQueue.prototpe = Object.create(Queue.prototype);
// 屏蔽原来的方法
PriorityQueue.prototype.enqueue = function(element, prior) {
    function Element(element, prior) {
        this.element = element;
        this.prior = prior;
    }
    let queueElement = new Element(element, prior);

    if(this.isEmpty()) {
        this.item.push(queueElement);
    } else {
        for(let i = 0; i < this.items.length; i++) {
            if(this.items[i].prior >= queueElement.prior) {
                this.items,splice(i, 0, queueElement);
                return;
            }
        }
        this.items.push(queueElement);
    }
}
```

# 链表
## 实现链表
链表就像锁链，链环一个接着一个，链表存储有序的元素集合。数组存储的元素在内存中是连续的，链表存储的元素在内存中不是连续的，是跳跃性的。  
链表有好处也有坏处，好处是当移动一个元素时不用移动其他元素，坏处是访问元素时需要遍历找值，不像数组直接用下标就能取到值。  
```js
function LinkList() {
    function Node(element) {
        this.element = element;
        this.next = null;
    }
    this.head = null;
    this.length = 0;
    // 防止创建多个链表时重复设置
    if(typeof this.append !== 'function') {
        // 添加
        LinkList.prototype.append = (element) => {
            let node = new Node(element);
            let current;
            if(this.head === null) {
                this.head = node
            } else {
                current = this.head;
                while(current.next !== null) {
                    current = current.next;
                }
                current.next = node;
            }
            this.length++;
        }
        // 插入成功返回true，失败返回false
        LinkList.prototype.insert = (pos, element) => {
            if(pos > -1 && pos < this.length) {
                let current = this.head;
                let prev = null;
                let index = 0;
                let node = new Node(element);
                if(pos === 0) {
                    node.next = current; // 连后接前
                    this.head = node;
                } else {
                    while(index++ < pos) {
                        prev = current;
                        current = current.next;
                    }
                    node.next = current;
                    prev.next = node;
                }
                this.length++;
                return true;
            } else {
                return false;
            }
        }
        // 删除(根据位置)
        LinkList.prototype.removeAt = (pos) => {
            if(pos > -1 && pos < this.length) {
                let current = this.head;
                let prev = null;
                let index = 0;
                if(pos === 0) {
                    this.head = current.next;
                } else {
                    while(index++ < pos) {
                        prev = current;
                        current = current.next;
                    }
                    prev.next = current.next;
                }
                this.length--;
                return current.element;
            } else {
                return false;
            }
        }
        // 删除(根据元素)
        LinkList.prototype.remove = (element) => {
            let index = this.indexOf(element);
            return this.removeAt(index);
        }
        // 查找元素索引
        LinkList.prototype.indexOf = (element) => {
            let current = this.head;
            let index = 0;
            while(current) {
                if(current.element === element) {
                    return index;
                }
                index++;
                current = current.next;
            }
            return -1;
        }
        LinkList.prototype.isEmpty = () => this.length === 0;
        LinkList.prototype.size = () => this.length;
        LinkList.prototype.getHead = () => this.head;
        LinkList.prototype.toString = () => {
            let str = '';
            let current = this.head;
            while(current) {
                str += current.element;
                current = current.next;
            }
            return str;
        }

    }
}
```
## 双向链表  
之前我们创建的链表中每个元素只有指向下一个元素的指针，是单向链表。而双项链表比单向链表多了一个指向前一个元素的指针，So...  
```js
// 继承单向链表
function inheritPrototype(sub, super) {
    let obj = Object.create(super.prototype);
    sub.prototype = obj;
}
function DoubleLinkList() {
    function Node(element) {
        this.element = element;
        this.prev = null;
        this.next = null;
    }
    LinkList.call(this);
    this.tail = null;
    // 屏蔽继承来的原型方法
    this.insert = (pos, element) => {
        if(pos > -1 && pos <= this.length) {
            let node = new Node(element);
            let current = this.head;
            let prev = null;
            let index =0;
            if(pos === 0) {
                if(!this.head) {
                    this.head = node;
                    this.tail = node;
                } else {
                    node.next = current;
                    current.prev = node;
                    this.head = node;
                }
            } else if (pos === this.length) {
                current = this.tail;
                current.next = node;
                node.prev = current;
                this.tail = node;
            } else {
                while(index++ < pos) {
                    prev = current;
                    current = current.next;
                }
                prev.next = node;
                node.next = current;
                current.prev = node;
                node.prev = prev;
            }
            this.length++;
            return true;
        } else {
            return false;
        }
    }
    this.append = (element) => {
        let node = new Node(element);
        let current = null;
        if(!this.head) {
            this.head = node;
            this.tail = node;
        } else {
            current = this.head;
            while(current.next !== null) {
                current = current.next;
            }
            current.next = node;
            node.prev = current;
            this.tail = node;
        }
        this.length++;
    }
    this.removeAt = (pos) => {
        if(pos > -1 && pos < this.length) {
            let current = this.head;
            let prev = null;
            let index = 0;
            if(pos === 0) {
                this.head = current.next;
                if(this.length === 1) {
                    this.tail = null;
                } else {
                    this.head.prev = null;
                }
            } else if (pos === (this.length - 1)) {
                current = this.tail;
                this.tail = current.prev;
                this.tail.next = null;
            } else {
                while(index++ < pos) {
                    prev = current;
                    current = current.next;
                }
                prev.next = current.next;
                current.next.prev = prev;
            }
            this.length--;
            return current.element;
        } else {
            return false;
        }
    }
}
inheritPrototype(DoubleLinkList, LinkList);
```
## 循环链表
循环链表与上面的区别就是最后一个元素指向的下一个元素不是null，而是指向第一个元素，同理第一个元素的上一个元素不是null，而是指向最后一个元素。