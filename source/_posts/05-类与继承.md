---
title: 05-类与继承
date: 2017-09-27 11:54:12
tags:
	- javascript
	- 笔记
---
<img src="/images/index/05.jpg" />
<!--more-->

# 类与继承

## 类的声明与实例化
1. 构造函数
``` javascript
function Animal() {
	this.name = name
}
```
2. ES6的class
``` javascript
class Animal {
	constructor() {
		this.name = name
	}
}
```
两者都通过new构造实例

## 继承
1. 借助构造函数实现继承
``` javascript
function Parent() {
	this.name = "parent";
}
function Child() {
	Parent.call(this); // 改变this，指向此构造函数的实例对象
	this.type = 'child';
}
// 函数Child没有继承Parent.prototype
```

2. 借助原型链实现继承
``` javascript
function Parent() {
	this.name = "parent";
}
function Child() {
	this.type = 'child';
}
Child.prototype = new Parent();
// 解决了上面的问题，但有一个明显的缺点，如果原型链上存放了对象数据(比如数组)，当一个实例更改了数据，那么就会影响到所有实例
```

3. 组合继承
``` javascript
function Parent() {
	this.name = "parent";
	this.play = [1, 2, 3];
}
function Child() {
	Parent.call(this);
	this.type = 'child';
}
Child.prototype = new Parent();
// 避免了上面两种问题，但也有缺点，执行了两次构造函数
```

4. 组合继承优化
``` javascript
function Parent() {
	this.name = "parent";
	this.play = [1, 2, 3];
}
function Child() {
	Parent.call(this);
	this.type = 'child';
}
Child.prototype = Parent.prototype;
```

我：我觉得OK！
他：我觉得不行！
我：你真的很严格耶，哪里又有缺点啊！
他：Please注意一下Child.prototype.constructor，它指向的不是Child而是Parent，这将导致我们无法判断这个实例到底是谁构造出来的。所以我们还要把constructor改回来。
我：我觉得这有失公正。
他：我觉得你是个傻子。
我：所以最终优化版就是再添加一句`Child.prototype.constructor = Child`咯？
他：不，你这样改的话其实改的是Parent的constructor。
我：那咋办？
他：创建一个对象作为中间对象，这个对象继承Parent.prototype。(即它的`__proto__`指向`Parent.prototype`)
我：然后再添加刚刚那句话？
他：Bingo！
我：哇呜！好棒棒！

``` javascript
function Parent() {
	this.name = "parent";
	this.play = [1, 2, 3];
}
function Child() {
	Parent.call(this);
	this.type = 'child';
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
```