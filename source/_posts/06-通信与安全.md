---
title: 06-通信与安全
date: 2017-09-27 16:30:00
tags:
- 网络
---
<img src="/images/index/06.jpg" />
<!--more-->

# 通信

我：笨蛋测试，笨蛋测试！
他：哔哔哔~，哔哔哔~
我：你这个是什么意思？
他：别BB~
我：哔哔哔~，哔哔哔~

## 同源策略与限制

1. 源：协议+域名+端口，其中任何一项不同就是不同的源
2. 同源策略：一个源的文件不能操作另一个源的文件，如：
 * Cookie、LocalStorage、IndexDB无法读取
 * DOM无法获得
 * Ajax请求不能发送

## 前后端如何通信

1. Ajax(受同源限制)
2. WebSocket(不受同源限制)
3. CORS(受不受限制都可以)

## 如何创建Ajax

[Ajax/Jsonp](https://github.com/KokoTa/All-demo/blob/master/other/util.js)

## 跨域通信的几种方式

1. JSONP

2. Hash

    ``` javascript
    // 假设当前页面为A，A中利用iframe或frame嵌入了跨域的页面B，A包含B
    // A中代码：
    var B = document.getElementsByTagName('iframe');
    B.src = B.src + '#' + 'data';
    // B中代码：
    window.onhashchange = function() {
    var data = window.location.hash; // 数据就在hash中
    }
    ```

3. postMessage

    ``` javascript
    // 假设页面A(http://A.com)向跨域的窗口B(http://B.com)发送信息
    // A中代码：
    B的窗口的window.postMessage('data', 'http://B.com');
    // B中代码：
    window.addEventListener('message', functino(event) {
    console.log(event.origin);
    console.log(event.source);
    console.log(event.data);
    }, false);
    ```

4. WebSocket(Socket.io)
    [参考1](http://www.ruanyifeng.com/blog/2017/05/websocket.html)
    [参考2](http://blog.csdn.net/frank_good/article/details/50856585)

5. CORS(可以结合fetch使用)
    [参考](http://www.ruanyifeng.com/blog/2016/04/cors.html)

额外链接：
[聊聊Ajax那些事](https://segmentfault.com/a/1190000006669043)
[前端常见跨域解决方案](https://segmentfault.com/a/1190000011145364)

# 安全

他：网站的安全性不可忽略。
我：是的，为了防止世界被破坏！
他：为了维护...不对！安全方面的知识不能落下！
我：(羞涩)
他：滚！

## CSRF

1. 概念：CSRF(Cross-site request forgery)，又称跨站请求伪造
2. 攻击原理：如下图所示，首先我们登录了网站A，网站A认证之后返回cookie给用户。网站B是一个骗人网站，其中有一个诱导链接指向网站A(这个链接可能在链接尾部添加查询或者其他操作信息)，当点击链接跳转到网站A时会附带网站A的cookie，此时若cookie中存在登录状态，那么就能以用户身份进行一些违规操作。
3. 原因：网站A接口有漏洞；用户登录过网站A，登录信息保存在cookie里，在登录信息未失效前再次访问网站A会自动登录。
4. 防御措施：
   * 接口设定要区分清晰：因为大部分的CSRF是GET请求，所以我们的接口可以设置为“GET接口只获取资源，POST等接口操作资源”，但CSRF可以伪造POST请求，因此还需要搭配以下方法进行优化。
   * Token验证：如果是GET请求，发送请求前手动添加token，即地址后加上?token=xxxx，后端验证token合法性；如果是POST请求，就在表单中增加一个隐形input，值为token，提交时一起传给后端验证。简而言之就是发送前需要手动添加验证信息，而不是无脑发送。
   * Referer验证：判断请求的页面是否是服务器下的页面，是的话可以直接访问，不是的话则进行拦截。
   * 隐藏令牌：类似token，就是token放置位置的区别，token从cookie中取出来放到HTTP的head中，CSRF无法操作cookie(或者也可以存储在localStorage中)。
![CSRF攻击原理](/images/CSRF.jpg)
[其他资料](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.1.md)

## XSS

1. 概念：XSS(cross-site scripting)，又称跨域脚本攻击，一般来说浏览器会自动拦截XSS脚本
2. 攻击原理：
   * 反射型：发送请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回浏览器，最后浏览器解析执行XSS代码
   * 存储型：与反射型的区别仅在于，提交的代码会存储在服务器端，下次请求目标页面时不再提交XSS代码
3. 原因：用户数据未处理；客户端服务端不验证
4. 防御措施：
   * 编码：对用户输入的数据进行HTTP Entity编码
   * 过滤：移除用户上传的DOM属性，如onerror等；移除用户上传的Style节点、Script节点、Iframe节点等
   * 校正：避免直接对HTML Entity解码；使用DOM Parse转换，校正不配对的DOM标签
PS：过滤与校正用到的库可以使用[he](https://github.com/mathiasbynens/he)和[domParse](https://github.com/blowsie/Pure-JavaScript-HTML5-Parser)
