---
title: 13-Javascript精度问题
date: 2018-07-04 16:04:00
tags:
  - JavaScript
---
<img src="/images/index/13.jpg" />
<!--more-->

# 一本正经道
本来用着JS写代码是一件很舒服的事情，但是自从接手了价格计算的功能后，一点都开森不起来，理由如下：
```javascript
// 加法 =====================
0.1 + 0.2 = 0.30000000000000004
0.7 + 0.1 = 0.7999999999999999
0.2 + 0.4 = 0.6000000000000001

// 减法 =====================
1.5 - 1.2 = 0.30000000000000004
0.3 - 0.2 = 0.09999999999999998
 
// 乘法 =====================
19.9 * 100 = 1989.9999999999998
0.8 * 3 = 2.4000000000000004
35.41 * 100 = 3540.9999999999995

// 除法 =====================
0.3 / 0.1 = 2.9999999999999996
0.69 / 10 = 0.06899999999999999
```
是的，你没有看错，Javascript存在精度问题，由于当时项目急于上线，因此把价格计算托付给了后端大佬们去实现，省了不少麻烦。  
不过现在回过头来看看，原理是肿么回事？前端是否可以解决这个问题呢？

# 浮点数的存储
JS 浮点数使用 64 位固定长度比特来表示，即标准的双精度(double)。  
这种存储结构的优点是归一化处理整数和小数，节省存储空间。  

这 64 位比特分为三个部分：
* 符号位S：即第 1 位，表示正负，0为正，1为负
* 指数位E：即第 2 位 ~ 第 12 位，表示次方数
* 尾数位M：即后面剩余的 52 位，表示尾数，超出的部分自动 `进 1 舍 0`

接下来我们回顾一下二进制及编码的知识，这有助于接下来的理解：
1. 原码：计算机中对数字的二进制表示，最高位表示符号，其余表示数值。优点是简单直观，缺点是不能直接计算。因为如果是正数，原码是可以正常表示并参与计算的，但如果是负数，那么原码需要转成反码后才能进行计算。**eg**：假设有两个四位二进制数，`0001` 表示 1，`1001` 表示 -1，此时若两者相加 `0001 + 1001 = 1010 = -2 != 0`，结果为 -2 是错误的。
2. 反码：反码即除了符号位外，反转了剩余所有原码的位。`1001` 的反码是 `1110`，此时 `0001 + 1110 = 1111`，而 `1111` 表示 -0 (`0000` 表示 +0)，所以结果是正确的。所以说反码解决了负数的二进制表示问题。
3. 补码：从上一点我们知道了 0 有两个，即 +0 和 -0，按常识来说我们希望只有一个 0，此时我们给负数的所有反码 +1，如图：  
    ![image](/images/原码反码补码.png)
    这样我们就解决了 0 的问题，同时也解决了"正负数相加不等于0"的问题

# 浮点数表示方法
从 IEEE 754 规范中我们可以得到二进制浮点数的公式：  
![image](/images/浮点数公式.jpg)  
公式以科学记数法的形式来表示，其中字母的含义和上一节相对应。  
1. S 为符号位，`S = 0` 时，V为正；`S = 1` 时，V为负
2. E 为指数位
3. M 为有效字数，由于是科学记数法，所以 `1 <= M < 2`
同时规范规定了：  
1. 由于 `1 <= M < 2`，所以 M 可以写成 1.xxxx 的格式，而计算机保存 M 时，默认第一位总是 1， 所以只保存小数部分，节省了一位有效数字
2. 上一节我们知道指数位为 11 位的二进制，即范围是 0 ~ 2047，然而科学记数法中 E 可以为负数，为为了计算机处理数据的方便，所以 E 的真实值必须取一个中间数（偏移值），`1023`，即 0 ~1023 为负，1024 ~ 2047 为正(单精度下的范围是 0 ~ 255，中间数为 `127`)。

所以为什么 `0.1 + 0.2 = 0.30000000000000004` ？
让我们来看看 **浮点数加法运算流程**：  

我们首先让十进制转为二进制，即：  
```js
0.1 => 0.000110011001100110011001100110011001100110011001100110
0.2 => 0.001100110011001100110011001100110011001100110011001101
```
然后根据科学记数法得到(为方便理解，我们使用单精度来表示)：  
```js
0.1 => 1.10011001100110011001100110011001100110011001100110
    => 0(符号位) 01111011(指数位) (1)10011001100110011001100(尾数位)

    // 1. 小数点后移了四位，指数 E 为 -4，由于中间数为 127，所以对应的指数值为 127 - 4 = 123，转为二进制为 1111011，加上符号位 0，得到 01111011
    // 2. (1)为整数位，不计入尾数位

0.2 => 1.100110011001100110011001100110011001100110011001101
    => 0(符号位) 01111100(指数位) (1)10011001100110011001100(尾数位)
```
接着我们进行对阶(顾名思义就是对齐阶码，使两数的小数点位置对齐，小阶向大阶对齐)：  
```js
// 因为 0.1 的阶码为 -4，0.2 的阶码为 -3
// -4 < -3，小阶向大阶对齐，所以要使前者对齐后者，使两者相等
// 意思就是 0.1 这个数的二进制表示得再前移一位，从向右移动 4 位，变为向右移动 3 位
// 这将导致 0.1 的科学计数法：
// 1. 指数位本来是 -4，现在变为 -3，指数值为 124，转为二进制后得到 01111100，阶码对齐了
// 2. 尾数位因为前进一位，所以整体右移，为 (0)11001100110011001100110
// 所以：
0.1 => 0.000110011001100110011001100110011001100110011001100110
    => 0(符号位) 01111100(指数位) (0)11001100110011001100110(尾数位)
```
OK，现在让 0.1 + 0.2，即：  
```js
0(符号位) 01111100(指数位) (0)11001100110011001100110(尾数位) +
0(符号位) 01111100(指数位) (1)10011001100110011001100(尾数位) = 
// 由于对阶，所以只求尾数位相加
(0)11001100110011001100110 + 
(1)10011001100110011001100 =
(10)01100110011001100110010
// 然后就得到了
0(符号位) 01111100(指数位) (10)01100110011001100110010(尾数位)
// 因为整数位应为 1，而此时的整数位为 10，超了1位，所以尾数位应整体右移一位，相应的指数位也会变化，格式化后最终得到
0(符号位) 01111101(指数位) (1)00110011001100110011001(尾数位)
// 总结 => 尾数位整体右移，阶码变大(-4 -> -3)，指数值也变大(123 -> 124)，指数位变大(01111100 -> 01111101)
```
最后你会发现，尾数位最后的 0 被挤掉了，而这个就是产生误差的原因  
最终这个数转化为十进制就是 `0.30000000000000004`  

OK，知道了原因，那么我们该如何避免精度问题呢？  

# 解决方法
一开始的时候，我使用的是 **toFixed**，但是这个 API 也是有问题的，比如：
```js
1.35.toFixed(1) // 1.4 正确
1.335.toFixed(2) // 1.33  错误
// 错误的原因是 1.335 在处理时实际对应的的是 1.3349999
```
因此 toFixed 方法无法运用到生产环境中  

接着 **toPrecision** 映入眼帘，它用来处理精度，精度是从左至右第一个不为0的数开始。  
对于 `展示型` 数据，我们可以使用这个 API，比如：
```js
parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True
```
封装成方法的话：
```js
function strip(num, precision = 12) { // 一般选择 12 为默认精度，算是经验选择
  return +parseFloat(num.toPrecision(precision));
}
```

但对于 `加减乘除` 的运算，它就不适用了  
因为精度问题发生于小数计算，所以解决方法是将小数变为整数进行计算，然后再变回小数，举个栗子：  
```js
/**
 * 精确加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
```
当然，如果遇到科学记数法(精度大于 21)时，需要特别处理  


虽然可以手动实现这些运算函数，但是在生产环境中，还是使用现有的轮子比较妥当  
[number-precision](https://github.com/nefe/number-precision) 和 [mathjs](https://github.com/josdejong/mathjs) 可以解决精度问题

# 参考
[JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)  
[浮点数精度之谜](https://juejin.im/post/594a31d0a0bb9f006b0b2624)  
[JS中浮点数精度问题](https://juejin.im/post/5aa1395c6fb9a028df223516)  