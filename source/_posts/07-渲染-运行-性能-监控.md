---
title: 07-渲染/运行/性能/监控
date: 2017-09-29 11:44:56
tags:
	- 前端工程
---
<img src="/images/index/07.jpg" />
<!--more-->

# 浏览器渲染机制
他：你会写页面吧？
我：当然啦。
他：那你知道页面是怎么显示出来的吗？
我：废话，当然是在显示器里显示出来的啊。
他：...

## DOCTYPE及作用
1. **DTD**(document type definition，文档类型定义)是一系列语法规则，用来定义XML或(X)HTML的文件类型。浏览器根据它判断文档类型，决定使用何种协议来解析，以及切换浏览器模式   
2. **DOCTYPE**用来告诉浏览器文档是哪个DTD，主要用途之一是文件合法性验证，如果文件代码不合法，那么浏览器解析时会出现一些差错  
3. **DOCTYPE分类**：
	1. HTML5：`<!DOCTYPE html>`
	2. HTML 4.01 Strict：该DTD包含所有HTML元素和属性，但不包括展示性的和弃用的元素，比如`font`
	3. HTML 4.01 Transitional：...包括了展示性和弃用的元素

## 浏览器渲染过程
1. **整体流程**：
![浏览器渲染过程](/images/浏览器渲染过程.jpg)
2. **DOM树**：
![DOM树](/images/DOM树.jpg)
2. **CSS树**：
![CSS树](/images/CSS树.jpg)
3. **Render树**：
![Render树](/images/Render树.jpg)
4. **layout**：
![layout](/images/layout.jpg)

### 重排Reflow
1. **定义**：DOM结构中各个元素都有自己的盒子(模型)，它们都需要浏览器根据各种样式来计算并根据计算结果将元素放到该出现的位置，这个过程称为Reflow
2. **触发条件**：
	1. 添加或者删除可见的 DOM 元素
	2. 改变元素尺寸，比如边距、边框、宽度和高度
	3. 内容变化，比如用户在 input 框中输入文字、父元素添加子元素
	4. resize窗口(移动端没这个问题)，滚动窗口
	5. 计算 offsetWidth 和 offsetHeight 属性
	6. 设置 style 属性的值
	7. 改变字体大小

	![重排](/images/重排.jpg)

### 重绘Repaint
1. **定义**：当各种盒子的位置及其他属性(如颜色、字体大小等)确定下来后，浏览器按照它们的特性绘制了一遍，这个过程称为Repaint
2. **触发条件**：
	![重绘](/images/重绘.jpg)

PS：重排一定引起重绘，重绘不一定引起重排

### 如何减少重排重绘

1. 使用 transform 替代 top/left/right/bottom，前者不会发生重排，后者会
2. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
3. 不要把节点的属性值放在一个循环里当成循环里的变量，比如获取 offsetTop 时将它保存到变量里使用，而非频繁读取：
	```js
	for(let i = 0; i < 1000; i++) {
	  // 获取 offsetTop 会导致回流，因为需要去获取正确的值
	  console.log(document.querySelector('.test').style.offsetTop)
	}
	```
4. 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
5. 动画实现的速度的选择，动画速度越快，回流次数越多，可以选择使用 requestAnimationFrame
6. CSS 选择符从右往左匹配查找，避免节点层级过多
7. 将频繁重绘或者回流的节点设置为图层(z-index)，图层能够阻止该节点的渲染行为影响别的节点，比如对于 video 标签来说，浏览器会自动将该节点变为图层

### 浏览器加载资源的流程

通过上面我们了解了浏览器渲染的原理，那么渲染之前的加载过程是什么样的呢？假设加载资源的 html 如下：

```html
<link type="stylesheet" href="main.css">
<script src="main.js"></script>
<link type="stylesheet" href="other.css">
<link type="stylesheet" href="other2.css">
<script src="other.js"></script>
```

1. 首先从上到下解析 html
2. 碰到 main.css，异步加载 main.css，继续解析 html
3. 碰到 main.js，同步加载 main.js，此时会等到 main.css 加载完毕后再执行 main.js
4. 执行完 main.js 后，继续解析 html
5. 碰到 other.css，异步加载 other.css，继续解析 html
6. 碰到 other2.css，异步加载 other2.css，继续解析 html
7. 碰到 other.js，同步加载 other.js，此时会等到 other.css 和 other2.css 加载完毕后再执行 other.js
8. 执行完 other.js 后，继续解析 html

这里我们发现碰到 CSS 资源时，它是异步加载的，它并不会阻塞 html 解析

而碰到 JS 资源时，它会阻塞 html 解析，同时也会阻塞后面的其他资源(CSS/图片等)

这是因为 JS 不仅可以修改 DOM，它还可以更改样式，也就是它可以更改 CSS，但不完整的 CSS 是无法使用的，而 JS 中想访问 CSS 并更改它，则必须要能拿到完整的 CSS。所以就导致了一个现象，如果浏览器尚未完成 CSS 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSS 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSS，然后再执行 JS，最后在继续构建DOM。这里需要格外注意：JS 会阻塞他前面的 CSS 的加载，这里的阻塞是等到它加载完毕；也会阻塞后面的 CSS 加载，这里的阻塞是暂时不进行加载

# JS运行机制
我：控制台怎么什么都不显示？！
他：你可能不了解代码的运行机制。
我：啊！我知道了，我没调用console.log！
他：...

## JS是单线程的
我们都知道JS是单线程的，举个栗子：
```javascript
console.log(1); // A
setTimeout(() => console.log(2), 0); // B
console.log(3); // C
```
答案是1 3 2
为什么？
这就要扯到一些概念了。
1. **调用栈**：存放执行任务的堆栈
2. **任务队列**：存放异步任务回调的队列
3. **Event Loop(事件循环)**：不停地询问任务队列中有木有任务的一种机制

## 运行机制分析
比如上面代码吧，代码从上到下扫描后执行  
先扫描到A，发现A是同步任务，放入执行栈  
扫描到B，发现B是异步任务，看情况要不要放入任务队列中  
扫描到C，发现C是同步任务，放入执行栈
然后执行栈开始执行任务，输出1 3
执行完后事件循环机制询问任务队列有木有任务  
然后发现B在0s后(其实是4ms)返回了回调函数，回调函数放在了任务队列中  
事件循环机制发现任务队列里有任务，就按顺序把任务取出放入执行栈  
执行栈再执行，输出2  
完毕  
  
下面我们再看一段代码：
```javascript
for(var i=0; i<4; i++) {
	setTiemout(() => console.log(i), 1000);
}
```
结果是输出4个4  
为什么？
首先我们知道循环是同步任务，执行栈执行了循环并定义了4个异步任务  
异步任务的回调在1s后放入任务队列  
事件循环在1s后发现任务队列有返回的回调函数  
取出放入执行栈执行之  
发现函数内需要用到i  
最后根据作用域机制获得并输出循环后的i值4  
完毕  

附上流程图作为参考：
![运行机制](/images/运行机制.jpg)

## 异步任务
根据上图，我们发现异步任务分为以下几类：
1. setTimeout/setInterval
2. DOM事件
3. ES6中的Promise  

PS：关于setTimeout与Promise的关系可参见[这个链接](https://www.zhihu.com/question/36972010)

# 页面性能优化
我：啊！这个网页加载速度好慢啊！
他：那这个网站的性能肯定很差吧。
我：对啊！你看它到现在就只显示一个带数字页面！
他：那不是已经显示出来了吗？什么页面？
我：上面写着404 Not Found！
他：...

## 优化方法
1. 资源压缩合并，减少HTTP请求
2. 非核心代码异步加载
3. 利用浏览器缓存
4. 使用CDN
5. DNS预解析

## 异步加载
1. 加载方式：
	1. 动态脚本加载：创建script标签并加到页面中
	2. defer
	3. async
2. defer与async区别：
	1. defer在HTML解析完之后执行，按加载顺序执行
	2. async在其加载完后立即执行，执行顺序与加载顺序无关

## 浏览器缓存
1. 缓存分类：
	1. 强缓存： 
	```
	Expires Expires:Thu, 21 Jan 2017...
	Cache-Control Cache-COntrol:max-age=3600
	```
	2. 协商缓存：
	```
	Last-Modified/If-Modified-Since
	Etag/If-None-Match
	```
2. 示意图：
	1. 第一次请求：
	![缓存1](/images/缓存1.jpg)
	2. 之后的请求：
	![缓存2](/images/缓存2.jpg)  

[参考](https://my.oschina.net/leejun2005/blog/369148)

## DNS预解析
```html
<!-- 强制https开启dns预解析 -->
<meta http-equiv="x-dns-prefetch-control" content="on">
<!-- 指定dns预解析 -->
<link rel="dns-prefetch" href="//host_name_to_prefetch.com">
```

# 错误监控
我：我错了。
他：我知道。
我：？？？
他：我已经学会了“知道一个废柴是否会犯错”的能力。

## 错误分类及错误捕获方式
1. 代码错误
	1. try..catch
	2. window.onerror
2. 资源加载错误
	1. 资源对象.onerror
	2. document.getElementsByTagName("...").length - performance.getEntries().filter(item=>item.initiatorType == "...").length = 未加载的资源数
	3. window.onerror的捕获方式(冒泡不行，捕获可以)

## 跨域错误
跨域的JS运行错误可以捕获吗？  
可以，但是需要额外设置跨域选项，否则虽然会报错，但是没有报错信息  
解决方法：
1. script标签增加`crossorigin`属性
2. 设置js资源响应头`Access-Control-Allow-Origin:*`

## 上报错误
1. Ajax上报(不推荐)
2. Image上报
```javascript
(new Image()).src = 'http://baidu.com/test?k=xxx';
```