---
title: 07-渲染/运行/性能/监控
date: 2017-09-29 11:44:56
tags:
	- 工程类
	- 笔记
---
<img src="/images/index/07.jpg" />
<!--more-->

# 浏览器渲染机制
他：你会写页面吧？
我：当然啦。
他：那你知道页面是怎么显示出来的吗？
我：废话，当然是在显示器里显示出来的啊。
他：...

## DOCTYPE及作用
1. **DTD**(document type definition，文档类型定义)是一系列语法规则，用来定义XML或(X)HTML的文件类型。浏览器根据它判断文档类型，决定使用何种协议来解析，以及切换浏览器模式   
2. **DOCTYPE**用来告诉浏览器文档是哪个DTD，主要用途之一是文件合法性验证，如果文件代码不合法，那么浏览器解析时会出现一些差错  
3. **DOCTYPE分类**：
	1. HTML5：`<!DOCTYPE html>`
	2. HTML 4.01 Strict：该DTD包含所有HTML元素和属性，但不包括展示性的和弃用的元素，比如`font`
	3. HTML 4.01 Transitional：...包括了展示性和弃用的元素

## 浏览器渲染过程
1. **整体流程**：
![浏览器渲染过程](/images/浏览器渲染过程.jpg)
2. **DOM树**：
![DOM树](/images/DOM树.jpg)
2. **CSS树**：
![CSS树](/images/CSS树.jpg)
3. **Render树**：
![Render树](/images/Render树.jpg)
4. **layout**：
![layout](/images/layout.jpg)

## 重排Reflow
1. **定义**：DOM结构中各个元素都有自己的盒子(模型)，它们都需要浏览器根据各种样式来计算并根据计算结果将元素放到该出现的位置，这个过程称为Reflow
2. **触发条件**：
	1. 增加、删除、修改DOM节点
	2. 移动DOM位置
	3. 修改CSS
	4. Resize窗口(移动端没这个问题)，滚动窗口
	5. 修改默认字体

## 重绘Repaint
1. **定义**：当各种盒子的位置、大小及其他属性(如颜色、字体大小等)确定下来后，浏览器按照它们的特性绘制了一遍，这个过程称为Repaint
2. **触发条件**：
	1. DOM改动
	2. CSS改动

PS：重排一般会引起浏览器的重绘

# JS运行机制
我：控制台怎么什么都不显示？！
他：你可能不了解代码的运行机制。
我：啊！我知道了，我没调用console.log！
他：...

## JS是单线程的
我们都知道JS是单线程的，举个栗子：
```javascript
console.log(1); // A
setTimeout(() => console.log(2), 0); // B
console.log(3); // C
```
答案是1 3 2
为什么？
这就要扯到一些概念了。
1. **调用栈**：存放执行任务的堆栈
2. **任务队列**：存放异步任务回调的队列
3. **Event Loop(事件循环)**：不停地询问任务队列中有木有任务的一种机制

## 运行机制分析
比如上面代码吧，代码从上到下扫描后执行  
先扫描到A，发现A是同步任务，放入执行栈  
扫描到B，发现B是异步任务，看情况要不要放入任务队列中  
扫描到C，发现C是同步任务，放入执行栈
然后执行栈开始执行任务，输出1 3
执行完后事件循环机制询问任务队列有木有任务  
然后发现B在0s后(其实是4ms)返回了回调函数，回调函数放在了任务队列中  
事件循环机制发现任务队列里有任务，就按顺序把任务取出放入执行栈  
执行栈再执行，输出2  
完毕  
  
下面我们再看一段代码：
```javascript
for(var i=0; i<4; i++) {
	setTiemout(() => console.log(i), 1000);
}
```
结果是输出4个4  
为什么？
首先我们知道循环是同步任务，执行栈执行了循环并定义了4个异步任务  
异步任务的回调在1s后放入任务队列  
事件循环在1s后发现任务队列有返回的回调函数  
取出放入执行栈执行之  
发现函数内需要用到i  
最后根据作用域机制获得并输出循环后的i值4  
完毕  

附上流程图作为参考：
![运行机制](/images/运行机制.jpg)

## 异步任务
根据上图，我们发现异步任务分为以下几类：
1. setTimeout/setInterval
2. DOM事件
3. ES6中的Promise  

PS：关于setTimeout与Promise的关系可参见[这个链接](https://www.zhihu.com/question/36972010)

# 页面性能优化
我：啊！这个网页加载速度好慢啊！
他：那这个网站的性能肯定很差吧。
我：对啊！你看它到现在就只显示一个带数字页面！
他：那不是已经显示出来了吗？什么页面？
我：上面写着404 Not Found！
他：...

## 优化方法
1. 资源压缩合并，减少HTTP请求
2. 非核心代码异步加载
3. 利用浏览器缓存
4. 使用CDN
5. DNS预解析

## 异步加载
1. 加载方式：
	1. 动态脚本加载：创建script标签并加到页面中
	2. defer
	3. async
2. defer与async区别：
	1. defer在HTML解析完之后执行，按加载顺序执行
	2. async在其加载完后立即执行，执行顺序与加载顺序无关

## 浏览器缓存
1. 缓存分类：
	1. 强缓存： 
	```
	Expires Expires:Thu, 21 Jan 2017...
	Cache-Control Cache-COntrol:max-age=3600
	```
	2. 协商缓存：
	```
	Last-Modified/If-Modified-Since
	Etag/If-None-Match
	```
2. 示意图：
	1. 第一次请求：
	![缓存1](/images/缓存1.jpg)
	2. 之后的请求：
	![缓存2](/images/缓存2.jpg)  

[参考](https://my.oschina.net/leejun2005/blog/369148)

## DNS预解析
```html
<!-- 强制https开启dns预解析 -->
<meta http-equiv="x-dns-prefetch-control" content="on">
<!-- 指定dns预解析 -->
<link rel="dns-prefetch" href="//host_name_to_prefetch.com">
```

# 错误监控
我：我错了。
他：我知道。
我：？？？
他：我已经学会了“知道一个废柴是否会犯错”的能力。

## 错误分类及错误捕获方式
1. 代码错误
	1. try..catch
	2. window.onerror
2. 资源加载错误
	1. 资源对象.onerror
	2. document.getElementsByTagName("...").length - performance.getEntries().filter(item=>item.initiatorType == "...").length = 未加载的资源数
	3. window.onerror的捕获方式(冒泡不行，捕获可以)

## 跨域错误
跨域的JS运行错误可以捕获吗？  
可以，但是需要额外设置跨域选项，否则虽然会报错，但是没有报错信息  
解决方法：
1. script标签增加`crossorigin`属性
2. 设置js资源响应头`Access-Control-Allow-Origin:*`

## 上报错误
1. Ajax上报(不推荐)
2. Image上报
```javascript
(new Image()).src = 'http://baidu.com/test?k=xxx';
```